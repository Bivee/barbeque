require 'aws-sdk'
require 'active_support'
require 'active_support/core_ext'

module Barbeque
  class ExecutionLog
    DEFAULT_S3_BUCKET_NAME = 'barbeque'

    class << self
      delegate :save_message, :save_stdout_and_stderr, :load, to: :new

      def s3_client
        @s3_client ||= Aws::S3::Client.new
      end
    end

    # @param [String] application Application name
    # @param [String] job Job name
    # @param [String] message_id Message ID generated by SQS
    # @param [String] message_body JSON-formatted message body
    def save_message(application, job, message_id, message_body)
      put(application, job, message_id, 'message.json', message_body)
    end

    # @param [Barbeque::JobExecution,Barbeque::JobRetry] execution
    # @param [String] stdout
    # @param [String] stderr
    def save_stdout_and_stderr(execution, stdout, stderr)
      put_with_execution(execution, 'stdout.txt', stdout)
      put_with_execution(execution, 'stderr.txt', stderr)
    end

    # @param [Barbeque::JobExecution,Barbeque::JobRetry] execution
    # @return [Hash] log
    def load(execution:)
      return {} if execution.pending?

      message = get(execution, 'message.json')
      stdout = get(execution, 'stdout.txt')
      stderr = get(execution, 'stderr.txt')
      if message || stdout || stderr
        {
          'message' => message,
          'stdout' => stdout,
          'stderr' => stderr,
        }
      else
        # Try to load legacy format
        begin
          s3_object = ExecutionLog.s3_client.get_object(
            bucket: s3_bucket_name,
            key: legacy_s3_key_for(execution),
          )
          JSON.parse(s3_object.body.read)
        rescue Aws::S3::Errors::NoSuchKey
          nil
        end
      end
    end

    private

    def s3_bucket_name
      @s3_bucket_name ||= ENV['BARBEQUE_S3_BUCKET_NAME'] || DEFAULT_S3_BUCKET_NAME
    end

    # @param [String] application Application name
    # @param [String] job Job name
    # @param [String] message_id Message ID generated by SQS
    # @param [String] message_body JSON-formatted message body
    # @param [String] filename
    # @return [String]
    def s3_key_for(application, job, message_id, filename)
      "#{application}/#{job}/#{message_id}/#{filename}"
    end

    # @param [Barbeque::JobExecution,Barbeque::JobRetry] execution
    # @param [String] filename
    def s3_key_for_execution(execution, filename)
      s3_key_for(execution.app.name, execution.job_definition.job, execution.message_id, filename)
    end

    # @param [Barbeque::JobExecution,Barbeque::JobRetry] execution
    def legacy_s3_key_for(execution)
      "#{execution.app.name}/#{execution.job_definition.job}/#{execution.message_id}"
    end

    # @param [Barbeque::JobExecution,Barbeque::JobRetry] execution
    # @param [String] filename
    # @return [String]
    def get(execution, filename)
      s3_object = ExecutionLog.s3_client.get_object(
        bucket: s3_bucket_name,
        key: s3_key_for_execution(execution, filename),
      )
      s3_object.body.read
    rescue Aws::S3::Errors::NoSuchKey
      nil
    end

    # @param [String] application Application name
    # @param [String] job Job name
    # @param [String] message_id Message ID generated by SQS
    # @param [String] filename
    # @param [String] content
    def put(application, job, message_id, filename, content)
      ExecutionLog.s3_client.put_object(
        bucket: s3_bucket_name,
        key: s3_key_for(application, job, message_id, filename),
        body: content,
      )
    end

    # @param [Barbeque::JobExecution,Barbeque::JobRetry] execution
    # @param [String] filename
    # @param [String] content
    def put_with_execution(execution, filename, content)
      ExecutionLog.s3_client.put_object(
        bucket: s3_bucket_name,
        key: s3_key_for_execution(execution, filename),
        body: content,
      )
    end
  end
end
